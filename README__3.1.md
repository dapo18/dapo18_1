1. Сортировка выбором (Selection Sort)  (3.1.1.cpp)
Этот код реализует алгоритм сортировки выбором. Он последовательно перебирает все элементы массива.
Для каждого текущего элемента ищет минимальный элемент в оставшейся части массива, а затем меняет его местами с текущим. В результате массив сортируется по возрастанию после выполнения всех итераций.
Алгоритм работает строго по такой логике: найти минимум на очередной позиции и поставить его туда.

Оценка трудоемкости этого кода — O(n²), где n — количество элементов в массиве.

Обоснование:

Внешний цикл выполняется n раз.
Для каждой итерации внешнего цикла внутренний цикл ищет минимум в оставшейся части массива, что в худшем случае также равно n операциями.
Итого: n * n = n² операций сравнений и обменов.
Следовательно, асимптотическая сложность алгоритма — квадратичная, что типично для сортировки выбором.

2. Сортировка обменом (пузырьком) (Bubble Sort) (3.1.2.py)
Этот код реализует пузырьковую сортировку, проходя по массиву и сравнивая соседние элементы. 
Они меняются местами, если стоят не в порядке, таким образом, большие элементы "всплывают" в конец массива. 
Процесс повторяется, пока весь массив не станет отсортированным.

Оценка трудоемкости этого кода — O(n²), где n — длина массива.

Обоснование:

Внешний цикл выполняется примерно n раз.
Внутренний цикл в худшем случае также выполняет около n сравнений.
Следовательно, количество операций — пропорционально n * n = n².
Это типичная сложность для пузырьковой сортировки.

3. Сортировка вставками (Insertion Sort)
Этот код реализует сортировку вставками: просматривает массив поэлементно, начиная со второго, и вставляет каждый элемент на его правильное место в отсортированной части массива слева.

Трудоемкость этого алгоритма, сортировки вставками, — O(n²).

Обоснование:

В худшем случае (при отсортированном по убыванию массиве), для каждого элемента нужно пройтись по всей отсортированной части, сравнивая и смещая элементы.
Внешний цикл выполняется n - 1 раз.
Внутренний цикл в худшем случае также выполняет приблизительно i операций, что суммарно дает примерно n*(n-1)/2 сравнений и перемещений.
Поэтому асимптотическая сложность — O(n²).

4. Сортировка слиянием (Merge Sort)
mergeSort — рекурсивно делит массив пополам, пока длина не станет 1 или 0.
Каждую половину сортирует отдельно.
merge — объединяет две отсортированные части в один отсортированный массив.
В main создается массив, выводится исходный, вызывается сортировка, и выводится результат.

Оценка трудоемкости:
В худшем и среднем случае — O(n log n).
Почему?
Делит массив пополам рекурсивно (глубина рекурсии — log n)
Объединение двух отсортированных массивов занимает O(n) времени
Итог — O(n log n).

5. 
