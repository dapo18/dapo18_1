Подробное описание алгоритма (пошагово, одно общее описание и дополнения)

A) Построение дерева из входной строки (level-order)

Вход: последовательность токенов (строк) T[0..m-1]. Токен N/null/none означает отсутствие узла.
 1. Если вход пуст или T[0] — N → дерево пустое (root = null).
 2. Создать корень root со значением T[0].
 3. Поместить root в очередь q.
 4. Инициализировать индекс i = 1.
 5. Пока q не пуста и i < m:
 1. Достать из очереди текущий узел node.
 2. Если i < m и T[i] не N: создать node.left со значением T[i], и положить node.left в q. Затем i++.
Иначе node.left остаётся = null, i++.
 3. Если i < m и T[i] не N: создать node.right со значением T[i], и положить node.right в q. Затем i++.
Иначе node.right = null, i++.
 6. После окончания — получено дерево, где элементы заданы по уровням.

B) Рекурсивные обходы (общая идея)

Рекурсия: функция traverse(node) делает действие в определённом порядке: для каждого обхода порядок операций (visit, left, right) различается.

Preorder (Root, Left, Right)
 1. Если node == null, вернуть.
 2. Посетить node — добавить node.val в результат.
 3. Рекурсивно вызвать preorder(node.left).
 4. Рекурсивно вызвать preorder(node.right).

Inorder (Left, Root, Right)
 1. Если node == null, вернуть.
 2. inorder(node.left).
 3. Посетить node — добавить node.val.
 4. inorder(node.right).

Postorder (Left, Right, Root)
 1. Если node == null, вернуть.
 2. postorder(node.left).
 3. postorder(node.right).
 4. Посетить node — добавить node.val.

Каждый рекурсивный вызов обрабатывает поддерево и возвращает список (или заполняет общий список) в нужном порядке. Рекурсия автоматически использует стек вызовов для навигации по дереву.

=====

Оценка временной сложности
 Временная сложность (time): O(n), где n — число узлов в дереве.
 Память:
 Дополнительная стековая память: O(h) — глубина рекурсии равна высоте дерева h.
 Память для хранения результата: O(n) (списки для вывода).
 Память для построения очереди при чтении: временно до O(n) в худшем случае (например, почти полный уровень).

=====

Объяснение этой сложности (пошагово и детально)

Почему O(n) по времени?
  Каждый узел посещается ровно один раз при каждом виде обхода. Во время посещения у узла выполняется конечный (константный) набор операций: проверка null, добавление значения в список (O(1)), и два рекурсивных вызова (на вызовы тратится время, но суммарно всё равно в пределах O(n) для всех узлов).
  Следовательно суммарная работа пропорциональна числу узлов → O(n).

Почему O(h) стек (рекурсия)?
  Рекурсивный алгоритм хранит контекст вызова для каждого узла на пути от корня к текущему узлу → глубина рекурсии равна высоте дерева h.
  В худшем случае (вырожденное дерево — цепочка), h = n → стек O(n).
  В сбалансированном дереве h = O(log n), поэтому стек O(log n).

=====

Данные для ввода и что выдаёт

Тест A 

Ввод:

1 2 3 4 5 N N

Ввывод:

Preorder:  1 2 4 5 3
Inorder:   4 2 5 1 3
Postorder: 4 5 2 3 1

Тест B 

Ввод:

A B C N D N E

Построение:
 Уровень 0: A
 Уровень 1: B, C
 Уровень 2: B.left = N (null), B.right = D, C.left = N, C.right = E

Ожидаемые обходы:
  Preorder: A B D C E
  Inorder:  B D A C E  (проверить: left(B)=null → B, then D, then root A, then C then E)
  Postorder: D B E C A

=================================================================================================================================================================================================================


КОНТРОЛЬНЫЙ ВОПРОС №5



