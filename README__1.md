# dapo18
1. Бинарная куча
Принцип работы: Это полное бинарное дерево, которое удовлетворяет свойству кучи: ключ любого узла всегда больше (или меньше) ключей его потомков. Реализуется, как правило, на основе массива.
Python: В стандартной библиотеке есть модуль heapq, который предоставляет функции для работы со списком как с бинарной кучей (min-heap). Это не отдельный класс, а набор функций.
Java: Класс PriorityQueue в java.util реализован на основе бинарной кучи. Это готовый к использованию класс.
C++: В Standard Template Library (STL) есть std::priority_queue из <queue>, который обычно реализуется как бинарная куча (max-heap по умолчанию).
3. Биномиальная куча
Принцип работы: Это набор биномиальных деревьев разного размера, упорядоченных по степени. Каждое дерево удовлетворяет свойству min-heap.
Python: Реализация биномиальной кучи на Python включает функции для вставки ключа, поиска минимума и извлечения минимального элемента.
C++: Реализация биномиальной кучи на C++ включает структуру узла, которая содержит значение и ссылки на сиблинга, ребёнка и родителя.
Java: Реализация биномиальной кучи на Java включает два основных класса: 
HeapNode - представляет узел в биномиальной куче, каждый узел имеет ссылку на своего родителя, ребёнка и следующего сиблинга.
HeapItem - представляет элемент, хранящийся в куче, связывается с соответствующим узлом.
4. Куча Фибоначчи
Принцип работы: Еще более сложная структура, состоящая из набора деревьев, подчиняющихся свойству кучи. Она использует "ленивую" стратегию: операции вставки и слияния выполняются очень быстро, а вся сложная работа откладывается на операцию извлечения минимума.
Python
В стандартной библиотеке Python отсутствует готовая реализация структуры данных "куча Фибоначчи". Существующие примеры кода обычно демонстрируют вычисление чисел Фибоначчи - последовательности, в которой каждый следующий элемент равен сумме двух предыдущих.
C++
Стандартная библиотека C++ не содержит готового класса "куча Фибоначчи", однако разработчики могут создавать собственные реализации этой структуры.
Java
В Java также нет встроенной реализации кучи фибоначчи, но её можно создать, используя рекурсивные алгоритмы.

5. Хеш-таблицы
Принцип работы: Использует хеш-функцию для преобразования ключа в индекс массива (корзину), что позволяет в среднем за O(1) выполнять вставку, удаление и поиск. Коллизии (когда разные ключи дают один индекс) решаются с помощью метода цепочек или открытой адресации.
Python: Тип dict является встроенной и высокооптимизированной хеш-таблицей. Это одна из самых используемых структур в языке.
Java: HashMap (и HashSet) из java.util - стандартная реализация хеш-таблицы. Hashtable - устаревший синхронизированный аналог.
C++: std::unordered_map (и std::unordered_set) из <unordered_map> - реализация хеш-таблицы в STL. В отличие от std::map (который реализован как красно-черное дерево), элементы не отсортированы.

